---
title: "Service Mesh Fundamentals"
thumbnail: ./service-mesh.svg
category: Service mesh
tags:
 - Service mesh
featured: false
published: true
---

import { Link } from "gatsby";
import { TopicsWrapper } from "../Topics.style.js";

<TopicsWrapper>
  <div className="intro">
    <p>Learn more about service mesh fundamentals in
      <Link className="blog" to="/learn/books">The Enterprise Path to Service Mesh Archictures (2nd Edition)</Link> -  free book and excellent resource which addresses how to evaluate your organization’s readiness, provides factors to consider when building new applications and converting existing applications to best take advantage of a service mesh, and offers insight on deployment architectures used to get you there.</p>
  </div>

<h2>What is a service mesh, and why do I need one?</h2>

<p>
Many emergent technologies build on or reincarnate prior thinking and approaches to computing and networking paradigms. Why is this phenomenon necessary? In the case of service meshes, we’ll look to  the microservices and containers movement—the cloud native approach to designing scalable, independently delivered services. Microservices have exploded what were once internal application communications into a mesh of service-to-service remote procedure calls (RPCs) transported over networks. Bearing many benefits, microservices provide democratization of language and technology choice across independent service teams that create new features quickly as they iteratively and continuously deliver software (typically as a service). Decoupling of engineering teams and their increased speed is the most significant driver of microservices as an architectural model.
</p>

<h3>Operating Many Services</h3>

<p>
And, sure, the first couple microservices are relatively easy to deliver and operate—at least compared to what difficulties organizations face the day they arrive at many microservices. Whether that “many” is 3 or 100, the onset of a major technology challenge is inevitable. Different medicines are dispensed to alleviate microservices headaches; use of client libraries is one notable example. Language and framework-specific client libraries, whether preexisting or created, are used to address distributed systems challenges in microservices environments. It’s in these environments that many teams first consider their path to a service mesh. The sheer volume of services that must be managed on an individual, distributed basis (versus centrally as with monoliths) and the challenges of ensuring reliability, observability, and security of these services cannot be overcome with outmoded paradigms; hence, the need to reincarnate prior thinking and approaches. New tools and techniques must be adopted.
</p>

<p>
Given the distributed (and often ephemeral) nature of microservices—and how central the network is to their functioning—it behooves us to reflect on the fallacy that networks are reliable, are without latency, have infinite bandwidth, and that communication is guaranteed (it’s worth reflecting on the fact that these same assumptions are held for service components using internal function calls). When you consider how critical the ability to control and secure service communication is to distributed systems that rely on network calls with each and every transaction, each and every time an application is invoked, you begin to understand that you are under tooled and why running more than a few microservices on a network topology that is in constant flux is so difficult. In the age of microservices, a new layer of tooling for the caretaking of services is needed—a service mesh is needed.
</p>

<h3>What Is a Service Mesh?</h3>

<p>Service meshes provide intent-based networking for microservices describing desired behavior of the network in the face of constantly changing conditions and network topology. At their core, service meshes provide:
</p>
<ul>
  <li>A services-first network;</li>
  <li>A developer-driven network;</li>
  <li>A network that is primarily concerned with alleviating application developers from building infrastructure concerns into their application code; </li>
  <li>A network that empowers operators with the ability to declaratively define network behavior, node identity, and traffic flow through policy; </li>
  <li>A network that enables service owners to control application logic without engaging developers to change its code.</li>
</ul>

<p>
Value derived from the layer of tooling that service meshes provide is most evident in the land of microservices. The more services, the more value derived from the mesh. In subsequent chapters, I show how service meshes provide value outside of the use of microservices and containers and help modernize existing services (running on virtual or bare metal servers) as well.
</p>

<h3>Why Do I Need One?</h3>

<p>
At this point, you might be thinking, “I have a container orchestrator. Why do I need another infrastructure layer?” With microservices and containers mainstreaming, container orchestrators provide much of what the cluster (nodes and containers) needs. Necessarily so, the core focus of container orchestrators is scheduling, discovery, and health, focused primarily at an infrastructure level (networking being a Layer 4 and below focus). Consequently, microservices are left with unmet, service-level needs. A service mesh is a dedicated infrastructure layer for making service-to-service communication safe, fast, and reliable, often relying on a container orchestrator or integration with another service discovery system for operation. Service meshes often deploy as a separate layer atop container orchestrators but do not require one because control and data plane components may be deployed independent of containerized infrastructure. As you’ll see in Chapter 3, a node agent (including service proxy) as the data plane component is often deployed in non-container environments.
</p>

<p>
As noted, in microservices deployments, the network is directly and critically involved in every transaction, every invocation of business logic, and at every request made to the application. Network reliability and latency are at the forefront of concerns for modern, cloud native applications. A given cloud native application might be composed of hundreds of microservices, each of which might have many instances and each of those ephemeral instances may be rescheduled as and when necessary by a container orchestrator.
</p>

<p>
Understanding the network’s criticality, what would you want out of a network that connects your microservices? You want your network to be as intelligent and resilient as possible. You want your network to route traffic around from failures to increase the aggregate reliability of your cluster. You want your network to avoid unwanted overhead like high-latency routes or servers with cold caches. You want your network to ensure that the traffic flowing between services is secure against trivial attacks. You want your network to provide insight by highlighting unexpected dependencies and root causes of service communication failure. You want your network to let you impose policies at the granularity of service behaviors, not just at the connection level. And, you don’t want to write all this logic into your application.
</p>

<p>You want Layer 5 management. You want a services-first network. You want a service mesh.</p>

</TopicsWrapper>
