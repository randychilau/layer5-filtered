---
title: Managing Multiple clusters with Meshery
subtitle: Now Meshery is supporting Kubernetes multi cluster features
date: 2022-06-20 08:00:00 -0630
author: Ashish Tiwari
description: "Philosophy and approach of managing multiple clusters with Meshery"
thumbnail: ./thumbnail.png
category: "Meshery"
tags:
 - Meshery
 - Multi-cluster
 - Kubernetes
type: Blog
published: true
---

import { BlogWrapper } from "../../Blog.style.js";
import Switcher from "./context-switcher.png";
import Deploy from "./deploy-modal.png";
import Cluster2 from "./meshmap-cluster2.png";
import Cluster1 from "./meshmap-cluster1.png";
import Settings from "./settings.png";
import Cluster from "./cluster-mgmt.png";
import Flush from "./flush-meshsync.png";

<BlogWrapper>

# Managing multiple clusters with Meshery
From multi-mesh to now multi-cluster, Meshery is continuously expanding in its capability to give developers and operators more power over their infrastructure.

## Philosophy behind the multi-cluster management approach

Meshery is highly extensible and pluggable without adding a lot of overhead or complexity. Under the hood, Meshery server acts as a delegator of operations by figuring out which Meshery adapter registered its capability against the given operation. The operation is then sent to that given component(like one of Meshery’s service mesh adapters,e.g. Istio adapter) via a gRPC call. When the operation involves a kubernetes cluster(s), the kubeconfig(s) is sent as a parameter to the RPCs. It is then the job of the handling adapter to respect that and perform the operation across the passed clusters from kubeconfigs as needed. The operations not requiring a kubeconfig are managed through the same RPC, with the only difference being that the handling component would ignore the `kubeconfigs` field altogether making the system work not just for kubernetes, but for other cloud native use cases. This approach of reusing the same RPC for different types of requests is pretty common and sometimes debatable with the other approach of being strict with the RPCs. This is what makes Meshery completely pluggable and extensible.

## Using multi cluster with Meshery
From a client's perspective, there are two uses of the multi context feature in general. While deploying a Meshmap design or performing any other operation on their cluster(s), selecting any number of kubernetes contexts will allow them to uniformly and parallely perform the operation across the clusters. And while visualizing the state of their cluster(s), the same context switcher will allow them to filter across the clusters whose view they want to see.


All cluster specific operations are now applied over a number of clusters uniformly. So if you have 10 clusters to manage and 8 of those start with the exact same set of pods, deployments, service mesh, etc then Meshery can help you to apply these operations quickest and easiest.


It is as simple as selecting the specific cluster(s) from the kubernetes context switcher in the navbar, and then applying whatever operation you wanted to, whether that be deploying a sample app, a service mesh, or a Meshmap design.

<p align="center">
  <img src={Switcher} alt="context switcher" class="image-center-shadow" />
</p>

Just before applying the operation, users will be prompted with a confirmation modal which will provide the information about which cluster(s) that operation will be performed against. As the User interface improves, this same modal will also convey more useful information about the operation they are going to perform.

<p align="center">
  <img src={Deploy} alt="deploy modal"  class="image-center-shadow" />
</p>


<br/>

### Using Meshmap visualizer
You can switch between views of your cluster in visualizer mode while using Meshmap.

<p align="center">
  <img src={Cluster2} alt="visualizer showing data of context1" class="slides-right" />
</p>
<p align="center">
  <img src={Cluster1} alt="visualizer showing data of context2" class="slides-left" />
</p>


### Managing Meshery on multiple clusters

Users can perform cluster related operations from the settings page like adding more clusters, removing data from existing clusters and removing existing clusters.

<img src={Settings} alt="Settings page" class="slides-right" />

Meshery also deploys its operator across the cluster it’s about to manage. This operator manages the lifecycle of a NATS server and Meshsync. Meshsync pumps the blood into Meshery’s core, in other words, it is responsible for watching all different types of resources by establishing a watch stream over each of them. Meshsync then pumps that data into the NATS server, of which Meshery server itself is a client. From there, Meshery server gets all the relevant data related to activities in the cluster.

By default Meshery wants to be greedy and as much aware about your infrastructure as possible so it deploys its operator across each detected cluster. But you can fine tune this configuration by going over each one of them from the table as shown.

<img src={Cluster} alt="cluster management" class="image-center-shadow" />

If you disconnect your cluster and do not want to persist the data from that cluster then you can perform a fine grain deletion by deleting all Meshsync data(which are the kubernetes objects) for that specific cluster.
 
<img src={Flush} alt="flushing meshsync data"  class="image-center-shadow" />





## Future of multi cluster

Meshery as an extension point to your infrastructure provides out of the box value by adding components which can be kubernetes specific, service mesh specific or custom components to add new functionality. We can now add multi-cluster specific components to provide more abstraction. This model can be used along with Meshery’s multi-mesh capabilities to give an overall multi-mesh multi-cluster experience to the user. For instance, your Istio service mesh spanning across multiple clusters can be abstracted and managed by Meshery using custom components such as VirtualGateway and VirtualDestinationRules. In this case, Meshery’s Istio adapter will handle the logic of converting a VirtualGateway into gateways across the clusters. This abstraction provides high value by powering the service mesh to span across the clusters while the Ops team can configure the mesh with minimal effort.


Just like the above example, many such extension points are in Meshery to add logic into and add useful functionality. And as these extension points actually extend, Meshery will continue to give more and more power to your cloud native infrastructure.
</BlogWrapper>